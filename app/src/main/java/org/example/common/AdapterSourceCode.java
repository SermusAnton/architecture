package org.example.common;

import com.sun.codemodel.CodeWriter;
import com.sun.codemodel.JClass;
import com.sun.codemodel.JClassAlreadyExistsException;
import com.sun.codemodel.JCodeModel;
import com.sun.codemodel.JDefinedClass;
import com.sun.codemodel.JExpr;
import com.sun.codemodel.JMethod;
import com.sun.codemodel.JMod;
import com.sun.codemodel.JPackage;
import org.example.command.Command;
import org.example.common.ioc.IoC;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.nio.charset.StandardCharsets;
import java.util.Map;

public class AdapterSourceCode {

    private final Class<?> clazz;

    public String getQualifiedClassName() {
        return qualifiedClassName;
    }

    public String getCode() {
        return code;
    }

    private final String qualifiedClassName;

    private String code;

    private static final String AUTO_GENERATED = "AutoGenerated";

    private static final String ADAPTER = "Adapter";

    private static final String SPACESHIP_OPERATIONS = "Spaceship.Operations";

    public AdapterSourceCode(Class<?> clazz) {
        this.clazz = clazz;
        this.qualifiedClassName = getPackageName() + "." + getName();
    }

    public void generate() {
        JCodeModel codeModel = new JCodeModel();
        JDefinedClass adapterClass;
        try {
            adapterClass = codeModel._class(qualifiedClassName);
        } catch (JClassAlreadyExistsException e) {
            throw new IllegalArgumentException(e);
        }
        adapterClass._implements(clazz);

        var classType = codeModel
            .ref(Map.class)
            .narrow(
                codeModel.ref(String.class),
                codeModel.ref(Object.class));

        var field = adapterClass.field(JMod.PRIVATE, classType, "gameObject");

        var constructor = adapterClass.constructor(JMod.PUBLIC);
        constructor.javadoc().add("Creates a new " + adapterClass.name() + ".");
        var constructorParam = constructor.param(classType, "gameObject");
        constructor.body().assign(JExpr.refthis(field.name()), JExpr.ref(constructorParam.name()));

        JClass ioc = codeModel.ref(IoC.class);

        for (var methodInterface : clazz.getDeclaredMethods()) {
            var returnType = methodInterface.getReturnType();
            JMethod method = adapterClass.method(JMod.PUBLIC, returnType, methodInterface.getName());
            method.annotate(Override.class);

            if (methodInterface.getName().startsWith("get")) {
                var staticMethod = ioc.staticInvoke(String.format("<%s>resolve", returnType.getSimpleName()))
                    .arg(getKeyOperation(getTypeValue(methodInterface.getName(), "get"), "get"))
                    .arg(constructorParam);
                method.body()
                    ._return(
                        staticMethod
                    );
            } else if (methodInterface.getName().startsWith("set")) {
                var interfaceParam = methodInterface.getParameters()[0];
                var methodParam = method.param(interfaceParam.getType(), interfaceParam.getName());
                var staticMethod = ioc.staticInvoke("resolve")
                    .arg(getKeyOperation(getTypeValue(methodInterface.getName(), "set"), "set"))
                    .arg(constructorParam)
                    .arg(methodParam);
                method.body().decl(
                    codeModel.ref(Command.class), "cmd", staticMethod
                );
                method.body().add(JExpr.ref("cmd").invoke("execute"));
            } else {
                var staticMethod = ioc.staticInvoke("resolve")
                    .arg(getKeyOperation(methodInterface.getName(), "other"))
                    .arg(constructorParam);
                method.body().decl(
                    codeModel.ref(Command.class), "cmd", staticMethod
                );
                method.body().add(JExpr.ref("cmd").invoke("execute"));
            }
        }

        final ByteArrayOutputStream[] baos = new ByteArrayOutputStream[1];
        try {
            codeModel.build(new CodeWriter() {

                @Override
                public OutputStream openBinary(JPackage jPackage, String s) {
                    baos[0] = new ByteArrayOutputStream();
                    return baos[0];
                }

                @Override
                public void close() throws IOException {
                    baos[0].close();
                }
            });
        } catch (IOException e) {
            throw new IllegalArgumentException(e);
        }

        code = baos[0].toString(StandardCharsets.UTF_8);
    }

    private String getName() {
        return AUTO_GENERATED + clazz.getName().substring(clazz.getName().lastIndexOf('.') + 1) + ADAPTER;
    }

    private String getPackageName() {
        return clazz.getName().substring(0, clazz.getName().lastIndexOf('.')) + ".adapter";
    }

    private String getKeyOperation(String methodName, String operation) {
        return String.format("%s.%s:%s.%s", SPACESHIP_OPERATIONS, clazz.getSimpleName(), methodName, operation);
    }

    private String getTypeValue(String methodName, String operation) {
        return methodName.substring(operation.length()).toLowerCase();
    }
}
