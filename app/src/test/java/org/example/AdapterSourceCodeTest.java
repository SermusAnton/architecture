package org.example;

import org.example.command.Command;
import org.example.command.Move;
import org.example.common.AdapterSourceCode;
import org.example.common.inmemorycompile.InMemoryCompile;
import org.example.common.ioc.DependencyResolver;
import org.example.common.ioc.IoC;
import org.example.objects.MovingObject;
import org.example.objects.RotatingObject;
import org.example.value.Vector;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.junit.jupiter.MockitoExtension;
;
import java.lang.reflect.InvocationTargetException;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Function;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
class AdapterSourceCodeTest {


    @Test
    void generateMovingObjectAdapter_success() {
        var adapterSourceCode = new AdapterSourceCode(MovingObject.class);
        adapterSourceCode.generate();

        assertTrue(adapterSourceCode.getQualifiedClassName().contains("org.example.objects.adapter.AutoGeneratedMovingObjectAdapter"));
        assertTrue(adapterSourceCode.getCode().contains("public AutoGeneratedMovingObjectAdapter(Map<String, Object> gameObject)"));
        assertTrue(adapterSourceCode.getCode().contains("public Vector getLocation()"));
        assertTrue(adapterSourceCode.getCode()
            .contains("return IoC.<Vector>resolve(\"Spaceship.Operations.MovingObject:location.get\", gameObject);"));
        assertTrue(adapterSourceCode.getCode().contains("public Vector getVelocity()"));
        assertTrue(adapterSourceCode.getCode()
            .contains("return IoC.<Vector>resolve(\"Spaceship.Operations.MovingObject:velocity.get\", gameObject);"));
        assertTrue(adapterSourceCode.getCode().contains("public void setLocation(Vector newLocation"));
        assertTrue(adapterSourceCode.getCode()
            .contains("Command cmd = IoC.resolve(\"Spaceship.Operations.MovingObject:location.set\", gameObject, newLocation);"));
    }

    // п.2 Адаптер и мост
    @Test
    void compileMovingObjectAdapter_success() {
        Map<String, Function<List<Object>, Object>> store = new ConcurrentHashMap<>();
        Function<List<Object>, Object> register = args ->
            store.put((String) args.get(0), (Function<List<Object>, Object>) args.get(1));
        store.put("IoC.Register", register);

        var resolver = new DependencyResolver(store);
        IoC.setStrategy(
            resolver::resolve
        );

        IoC.<Command>resolve(
            "IoC.Register",
            "Adapter",
            (Function<List<Object>, Object>) (List<Object> arg) -> {
                var typeClass = (Class<?>) arg.get(0);
                var adapterSourceCode = new AdapterSourceCode(typeClass);
                adapterSourceCode.generate();
                var inMemoryCompile = InMemoryCompile.getInstance();
                var clazz = inMemoryCompile.load(adapterSourceCode.getQualifiedClassName(), adapterSourceCode.getCode());
                try {
                    return clazz.getDeclaredConstructors()[0].newInstance(arg.get(1));
                } catch (InstantiationException | InvocationTargetException | IllegalAccessException e) {
                    throw new RuntimeException(e);
                }
            }
        );

        IoC.<Command>resolve(
            "IoC.Register",
            "Spaceship.Operations.MovingObject:location.get",
            (Function<List<Object>, Object>) (List<Object> args) -> ((Map<String, Object>) args.get(0)).get("location")
        );

        IoC.<Command>resolve(
            "IoC.Register",
            "Spaceship.Operations.MovingObject:velocity.get",
            (Function<List<Object>, Object>) (List<Object> args) -> ((Map<String, Object>) args.get(0)).get("velocity")
        );

        IoC.<Command>resolve(
            "IoC.Register",
            "Spaceship.Operations.MovingObject:location.set",
            (Function<List<Object>, Command>) (List<Object> args) -> () -> ((Map<String, Object>) args.get(0)).put("location", args.get(1))
        );

        var gameObject = mock(Map.class);

        var expectedLocation = new Vector(1, 3);
        var expectedVelocity = new Vector(2, 3);
        when(gameObject.get("location")).thenReturn(expectedLocation);
        when(gameObject.get("velocity")).thenReturn(expectedVelocity);

        var movingObject = IoC.<MovingObject>resolve("Adapter", MovingObject.class, gameObject);

        assertEquals(expectedLocation, movingObject.getLocation());
        assertEquals(expectedVelocity, movingObject.getVelocity());

        var expectedSetLocation = new Vector(2, 3);
        movingObject.setLocation(expectedSetLocation);
        verify(gameObject, times(1)).put("location", expectedSetLocation);
    }

    // п.3 Адаптер и мост
    @Test
    void addMethodToAdapter_success() {
        var adapterSourceCode = new AdapterSourceCode(TestInterface.class);
        adapterSourceCode.generate();

        assertTrue(adapterSourceCode.getQualifiedClassName().contains("org.example.adapter.AutoGeneratedTestInterfaceAdapter"));
        assertTrue(adapterSourceCode.getCode().contains("public AutoGeneratedTestInterfaceAdapter(Map<String, Object> gameObject)"));
        assertTrue(adapterSourceCode.getCode().contains("public void finish()"));
        assertTrue(adapterSourceCode.getCode()
            .contains("Command cmd = IoC.resolve(\"Spaceship.Operations.TestInterface:finish.other\", gameObject);"));
        assertTrue(adapterSourceCode.getCode()
            .contains("cmd.execute();"));
    }
}
